# Default values for helm-chart.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.
applicationName: bto-react-example
environment: dv
replicaCount: 1
namespace: lab

type: deployment

#containerPort: 8090

#set to true if deploying to openshift and want a route created
openshift:
  enabled: false

#TELUS Labels/Annotations
telus:
  cmdbId: "12345"
  costCentre: "12345"
  organization: "CIO"
  mailingList: "donotreply@telus.com"

# Allows you set arbitrary env variables.
extraEnvs: []
#extraEnvs: 
#  - name: envname
#    value: envvalue
#  - name: envname2
#    value: envvalue2 

envFrom: []
# envFrom:
#   - secretRef:
#       name: test-secret
#   - configMapRef:
#       name: special-config

# Allows you to add any config files and specify a path location in the volumeMounts
# such as application.yaml or log4j2.properties.  Since this is clear in src control
# please do no use for sensitive data such as keys and passwords.  See Secrets.
# configmaps: 
#   key:
#     properties:
#       key: "value"
#       key2: "value"
#   file:
#     application.yaml: |
#       key:
#         nestedkey: value
#     log4j2.properties: |
#       key = value

initContainers: |
#  - name: init-myservice
#    image: busybox:1.28
#    command: ['sh', '-c', "until nslookup myservice.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for myservice; sleep 2; done"]
#  - name: init-mydb
#    image: busybox:1.28
#    command: ['sh', '-c', "until nslookup mydb.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for mydb; sleep 2; done"]  
# If you add a configmap you must add a volume names "configmap" to mount to a path of your choosing
# you can also mount arbitrary volumes or otherwise leave as an empty array
volumeMounts: []
#volumeMounts: 
#  - name: configmap
#    path: /etc/config

#  - name: cache-dir
#    path: /etc/cache
#  - name: test-volume
#    path: /etc/gce-pd


livenessProbe: 
  httpGet:
    path: /
    port: 8080

readinessProbe: 
  httpGet:
    path: /
    port: 8080


# Volume mounts should have an equivelent volume name defined of required type
# this example creates and emptyDir type volume for ephemeral data
# volumes: |
#   - name: cache-dir
#     emtptyDir: {}
#   - name: test-volume
    # This GCE PD must already exist.
#     gcePersistentDisk:
#      pdName: my-data-disk
#      fsType: ext4

# Mount precreated secrets to a volume, it is determined the helm chart should not create secrets
# to protect security.  Please do not store secret data such as keys, keystores or passwords in Git
# or in a configmap
secretMounts: []
#secretMounts:
#  - name: keystores
#    secretName: app-keystores
#    path: /etc/secrets/keystores

image:
  repository: gcr.io/cio-gke-devops-e4993356/bto-react-example/react-app
  tag: latest
  pullPolicy: IfNotPresent

service:
  type: ClusterIP
  port: 8080

ingress:
  enabled: false
  path: /bto-react-example/react/?(.*)
  hosts:
    - ""
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

  class: nginx-ingress-protected

 # Can disable modsecurity rule 949110 via annotation below to prevent 403 errors common in either of the following cases:
 #    - You wish to allow PUT/DELETE HTTP methods
 #    - Consumers must make repeated requests, to prevent "Inbound Anomaly Score Exceeded" (ie React UIs).

 #annotations:
 #nginx.ingress.kubernetes.io/modsecurity-snippet: SecRuleRemoveByID 949110


# enable on kong ingress and add plugins
# insure the hostname used is cname to the kong ingress A record.
  # class: kong
  # kongPlugins: key-auth
    
# create required kong plugins
# plugins are reusable within namespace
kong:
  enabled: false
  plugins:
    - name: key-auth
      plugin: key-auth
      config: 
        key_names: apikey
  #   - name: acl
  #     plugin: acl
  #     config:
  #       name: test
  # consumers:
  #   - name: testconsumer
  #     username: test
  # credentials:
  #   - name: testcredential
  #     consumer: testconsumer
  #     type: key-auth
# add any additional credential config as required by type. 
# key for key-auth is autogenerated and can be seen via kubectl get kongcredential...
      # config:
      #   key: value
# Add custom kong ingress settings
  ingress:
    upstream:
  #     healthchecks:
  #       passive:
  #         healthy:
  #           http_statuses:
  #           - 200
  #           successes: 0
  #         unhealthy:
  #           http_failures: 0
  #           http_statuses:
  #           - 429
  #           - 503
  #           tcp_failures: 0
  #           timeouts: 0
    proxy:
  #     protocol: http
  #     path: /
  #     connect_timeout: 10000
  #     retries: 10
  #     read_timeout: 10000
  #     write_timeout: 10000
    route:
  #     methods:
  #     - POST
  #     - GET
  #     regex_priority: 0
  #     strip_path: false
  #     preserve_host: true
  #     protocols:
  #     - http
  #     - https


resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #  cpu: 100m
  #  memory: 128Mi
  # requests:
  #  cpu: 100m
  #  memory: 128Mi

# enable autoscaling and set utilization targets.  For autoscaling on cpu/memeory to work you
# must set resource limits
autoscaling:
  enabled: false
  minReplicas: 2
  maxReplicas: 5
  targetCPUUtilizationPercentage: 50
  targetMemoryUtilizationPercentage: 75

nodeSelector: {}

tolerations: []

affinity: {}


#Uncomment the snippet of values below to implement CloudSQL proxy for your implementation
#This sidecar implementation would effectively allow you to access your instance host with 'localhost'

cloudsqlproxy:
  enabled: false
  version: "1.16"
  instance_connection: cio-cio-lab-eugene-np-0cdac4:northamerica-northeast1:genesys-3b7fae0c

# sidecar: |
#   - name: cloudsql-proxy
#     image: gcr.io/cloudsql-docker/gce-proxy:1.14
#     command: ["/cloud_sql_proxy",
#     "-instances=INSTANCE_CONNECTION_NAME=tcp:5432"]
#     securityContext:
#       runAsUser: 2  
#       allowPrivilegeEscalation: false    
#
#  replace INSTANCE_CONNECTION_NAME with your cloudsql instance ie cio-cio-lab-eugene-np-0cdac4:northamerica-northeast1:genesys-3b7fae0c

prometheus:
  enable: false
  # scrapePath: "/mypath"
  # scrapePort: 9000

## Important this section configures the GKE side for workload identity support.  Make sure 
## the Terraform side is also completed.  Read more about it at the link below
## https://github.com/telus/tf-module-gcp-workload-identity

rbac:
  create: false 
  serviceAccountAnnotations: {
    iam.gke.io/gcp-service-account: "ivr-intelligent-routing@cio-smart-ivr-np-4462cd.iam.gserviceaccount.com", 
    foo: "bar"
    }   
  serviceAccountName: "chart-service-account"

#Example

# sideCarContainers:
#   datadog:
#     image: datadog/agent:latest
#     env:
#       - name: DD_API_KEY
#         value: ASDF-1234
#       - name: SD_BACKEND
#         value: docker
sideCarContainers: {}